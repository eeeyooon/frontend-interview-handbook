# Javascript 면접 질문 정리
<br/>

> 챕터 클릭 시 해당 챕터의 질문으로 이동합니다.

<br/>

- [**프로그래밍**](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
- [**Javascript**](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#javascript)
- [**데이터 타입**](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85)
- [**변수**](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#%EB%B3%80%EC%88%98)
- [**변수 선언**](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8)
- [**스코프**](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#%EC%8A%A4%EC%BD%94%ED%94%84)
- [**실행 컨텍스트**](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8)
- **클로저**
- **호이스팅**
- **this**
- **이벤트**
- **비동기 프로그래밍**
- **Promise**
- **배열**
- **함수와 메서드**
- **객체**
- **생성자 함수에 의한 객체 생성**
- **제너레이터**
- **객체지향 프로그래밍과 프로토타입**
- **클래스**
- **스프레드 문법과 구조 분해 할당**
- **에러**
- **Typescript**
- **브라우저 렌더링 과정**


<br/>

---

[⏫](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#javascript-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC)

<br/>

## 프로그래밍
###  컴파일러와 인터프리터란 무엇인가요? ✨
우리가 컴퓨터에게 문제 해결을 요청할 때는 프로그래밍 언어라는 사람이 이해할 수 있는 문법을 사용하여 코드를 작성합니다. 그러나 컴퓨터는 기계어만 이해할 수 있기 때문에, 우리가 작성한 고수준 언어의 코드를 기계어로 변환해야 합니다. 이 변환 작업을 수행하는 도구가 컴파일러와 인터프리터입니다.



### └ 컴파일러와 인터프리터의 차이점은 무엇인가요?
- **컴파일러**: 전체 코드를 한 번에 기계어로 변환하여 실행 파일을 생성합니다. 변환 속도는 느리지만, 실행 속도는 빠릅니다. C, C++ 등이 컴파일러 언어의 예입니다.
- **인터프리터**: 코드를 한 줄씩 읽고 실행할 때마다 기계어로 변환합니다. 변환 속도는 빠르지만, 실행 속도는 느립니다. Python, JavaScript 등이 인터프리터 언어의 예입니다. Java는 컴파일러와 인터프리터 방식을 모두 사용하는 하이브리드 방식입니다.


<br/>

## Javascript

### Javascript란 무엇인가요?
JavaScript는 HTML, CSS와 함께 웹 브라우저에서 실행할 수 있는 프로그래밍 언어입니다. JavaScript는 동적 타입 언어로, 런타임 시 타입이 결정되는 특징이 있습니다. 또한, JavaScript는 컴파일을 거치지 않는 인터프리터 언어입니다. JavaScript 엔진인 V8 엔진이 최적화를 위해 JIT(Just-In-Time) 컴파일러를 사용하지만, 기본적으로 JavaScript는 인터프리터 방식으로 실행됩니다.

<br/>

### 정적 타입 언어와 동적 타입 언어는 무엇인가요?
**정적 타입 언어**는 **변수의 타입이 컴파일 시점에 고정되는 언어**를 말합니다. Java와 같이 정적 타입 언어는 코드의 안정성을 높이고, 개발자가 타입과 관련된 오류를 사전에 발견할 수 있도록 돕습니다.

**동적 타입 언어**는 **변수의 타입이 런타임 시점에 결정되는 언어**를 의미합니다. JavaScript는 동적 타입 언어로, 변수의 타입이 변경될 수 있고, 함수의 인수나 반환값도 다양한 타입을 가질 수 있습니다. 이러한 특성 덕분에 코드를 더 유연하게 작성할 수 있지만, 타입 오류가 런타임에서 발견되기 때문에 디버깅이 어려울 수 있습니다.

<br/>

### Javascript와 ECMAScript의 차이점은 무엇인가요?
JavaScript는 브라우저에서 동작하는 프로그래밍 언어로, 웹 페이지의 동적 기능을 구현하기 위해 사용됩니다.  ECMAScript는 JavaScript의 표준 사양을 정의한 것입니다. ECMA 인터내셔널에서 관리하는 표준으로, JavaScript 언어의 명세서입니다.  ECMAScript의 버전이 올라갈수록 JavaScript에 새로운 기능이 추가됩니다. 예를 들어, ECMAScript 5 (ES5)와 ECMAScript 6 (ES6, ECMAScript 2015) 등의 버전이 있습니다.


<br/>


## 데이터 타입
### Javascript의 데이터 타입을 모두 말해주세요. ✨

- 숫자, 문자열, 불린, undefined, null, 심볼, bigint 라는 7가지 타입이 있습니다.
- 7가지 타입을 제외한 객체, 함수, 배열 등은 모두 객체 타입으로 분류됩니다.

| 구분 | 데이터 타입 | 설명 |
| --- | --- | --- |
| 원시 타입 | 숫자(number)타입 | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
| 원시 타입 | 문자열(string)타입 | 문자열 |
| 원시 타입 | 불리언(boolean)타입 | 논리적 참(true)과 거짓(false) |
| 원시 타입 | undefined타입 | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
| 원시 타입 | null 타입 | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
| 원시 타입 | 심벌(symbol) 타입 | ES6에서 추가된 7번째 타입 |
| 원시 타입 | BigInt 타입 | 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형 |
| 객체 타입 |  | 객체, 함수, 배열 등 |

<br/>

### 심볼 타입에 대해 설명해주세요.
- 심볼 타입은 ES6에 추가된 문법으로, 변경 불가능한 원시 값의 타입입니다.
- 심볼 값은 다른 값과 중복되지 않는 유일한 식별자로 사용됩니다. 자바스크립트의 객체는 프로퍼티 키로 문자열과 심볼 타입만 허용해서 객체의 유일한 프로퍼티 키로 등록할 때에도 사용할 수 있습니다.

<br/>

### Javascript에서 객체 타입과 원시 타입을 구분하는 이유를 설명해주세요.

자바스크립트에서 객체 타입과 원시 타입을 구분하는 이유는 이들의 특성과 메모리 관리 방식이 다르기 때문입니다.

**원시 타입**:

- 변경 불가능한 값(immutable)입니다.
- 변수에 저장하면 확보된 메모리 공간에 실제 값이 그대로 저장됩니다.
- 원시 값을 다른 변수에 할당하면, 원본 값이 복사되어 전달됩니다. 이를 **값에 의한 전달**이라고 합니다.

**객체 타입**:

- 변경 가능한 값(mutable)입니다.
- 변수에는 객체가 저장된 메모리 공간의 주소가 저장됩니다.
- 객체 값을 다른 변수에 할당하면, 객체의 실제 값이 아닌 해당 값의 메모리 주소가 전달됩니다. 이를 **참조에 의한 전달**이라고 합니다.

이러한 차이로 인해 원시 타입과 객체 타입을 구분하여 처리하는 것이 중요합니다.

<br/>


### └ 값에 의한 전달과 참조에 의한 전달에 대해 설명해주세요.

**값에 의한 전달**은 원시 값을 가진 변수를 다른 변수에 할당할 때, 할당받는 변수에 할당하는 변수의 원시 값이 그대로 복사되어 전달되는 방식입니다. 이 경우, 새로운 값이 복사되므로 변수의 값을 변경해도 다른 변수에 영향을 주지 않습니다.

**참조에 의한 전달**은 객체 타입의 변수를 다른 변수에 할당할 때, 할당받는 변수에 원본 객체의 참조 값(메모리 주소)이 복사되어 전달되는 방식입니다. 이 경우, 두 변수는 같은 객체를 가리키므로 한 변수를 통해 객체를 변경하면 다른 변수에도 영향을 미칩니다.

<br/>

### Javascript에서 타입 변환 방식을 설명해주세요.

타입 변환은 명시적 타입 변환과 암묵적 타입 변환 두 가지 방식으로 이루어집니다.

- **명시적 타입 변환**은 개발자가 의도적으로 값의 타입을 변환하는 것을 말합니다. 예를 들어, `toString()` 메서드를 사용하여 값을 문자열로 변환하거나, `Number()`, `String()`과 같은 함수를 사용하여 값을 변환할 수 있습니다. 이러한 변환은 코드의 가독성을 높이고, 명확한 타입 변환을 가능하게 합니다.

<br/>

```jsx
let num = 123;
let str = num.toString(); // 명시적 타입 변환: 숫자를 문자열로 변환
let numStr = "456";
let int = Number(numStr); // 명시적 타입 변환: 문자열을 숫자로 변환
```

<br/>

- **암묵적 타입 변환**은 개발자의 의도와 상관없이, 자바스크립트 엔진이 표현식을 평가하는 과정에서 타입을 자동으로 변환하는 것을 말합니다. 예를 들어, 숫자와 문자열을 더할 경우 결과가 문자열로 변환되거나, 조건문에서 `null`이나 `undefined`가 `false`로 변환되는 경우가 있습니다.

<br/>

```jsx
let result = 123 + ""; // 암묵적 타입 변환: 숫자와 문자열을 더해 문자열로 변환
if (!null) {
    console.log("null is falsy"); // null이 false로 변환
}
```
<br/>


### truthy와 falsy란 무엇인가요?
자바스크립트는 암묵적 타입 변환을 통해, 불리언 값이 아닌 값을 불리언 값으로 변환할 수 있습니다. 제어문의 조건식과 같은 불리언 컨텍스트에서 이러한 변환이 발생합니다. `true`로 변환되는 값을 truthy, false로 변환되는 값을 falsy라고 합니다. falsy 값에는 `false`, `undefined`, `null`, `0`, `-0`, `NaN`, `빈 문자열("")`이 있습니다. 이 외의 모든 값은 truthy 값입니다.

<br/>

### `==`(동등 연산자)와 `===`(일치 연산자)의 차이점은 무엇인가요?

자바스크립트에서는 **`==`**(동등 연산자)와 **`===`**(일치 연산자)가 있습니다. 두 연산자는 값을 비교할 때 다르게 동작합니다.

**`==` (동등 연산자)**:

- 값만 비교하며, 비교하기 전에 필요에 따라 타입을 변환하여 비교합니다. 즉, 타입 변환을 허용하는 느슨한 비교입니다.

**`===` (일치 연산자)**:

- 값과 타입 모두를 비교합니다. 타입 변환을 하지 않고 엄격하게 비교합니다.


<br/>


[⏫](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#javascript-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC)

<br/>

## 변수

### 변수란 무엇인가요?
변수는 어떤 값을 저장하기 위한 메모리 공간 또는 그 공간을 식별하기 위한 이름을 의미합니다. 변수는 값을 저장하고, 필요할 때 참조하여 사용할 수 있도록 합니다.

<br/>

### 식별자란 무엇인가요?
식별자는 변수, 함수, 클래스 이름과 같이 메모리 상의 어떤 값을 구별하여 식별할 수 있는 고유한 이름을 의미합니다. 식별자는 특정 값이 아닌, 그 값이 존재하는 메모리 주소를 기억하고 있습니다. 

<br/>

### 식별자 네이밍 규칙을 설명해주세요.
자바스크립트에서 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(`_`), 달러 기호(`$`)를 사용하여 만들 수 있으며, 숫자로 시작할 수는 없습니다.

<br/>

### 리터럴은 무엇인가요?
리터럴은 사람이 이해할 수 있는 문자와 같은 약속된 기호를 사용해 값을 생성하는 표기법입니다.

<br/>


## 변수 선언

### 변수 선언이란 무엇인가요?
변수 선언은 변수를 사용하기 위해 생성하는 과정입니다. 변수 선언 시, 값을 저장할 메모리 공간이 확보되며, 선언된 변수의 이름과 해당 메모리 공간의 주소가 연결됩니다. 자바스크립트에서는 `var`, `let`, `const` 키워드를 사용하여 변수를 선언할 수 있습니다.

<br/>

### 정적 타이핑과 동적 타이핑에 대해서 설명해주세요. ✨
정적 타이핑과 동적 타이핑은 변수의 타입을 관리하는 두 가지 방법입니다.

- **정적 타이핑**은 변수의 타입을 정하면 변경할 수 없고, 변수의 타입에 맞는 값만 할당할 수 있는 방식을 말합니다. 예를 들어, C나 Java와 같은 정적 타이핑 언어는 변수를 선언할 때 변수의 타입을 함께 선언하는 명시적 타입 선언 방식을 사용합니다. 이 방식은 컴파일 시점에서 타입 체크를 통해 타입 에러를 잡아낼 수 있어, 코드의 안정성을 높이는 데 도움이 됩니다.
- **동적 타이핑**은 자바스크립트에서 사용하는 방식으로, 변수 선언 시점이 아닌 값의 할당 시점에 타입이 결정됩니다. 이를 타입 추론이라고 합니다. 값은 재할당을 통해 변할 수 있으므로, 변수의 타입도 동적으로 변할 수 있습니다. 이러한 특징을 동적 타이핑이라고 하며, 유연하지만 타입 에러가 런타임에서 발생할 수 있어 주의가 필요합니다.

<br/>

### var 키워드란 무엇이고 var 키워드로 변수를 선언했을 때 발생할 수 있는 문제점은 어떤 것이 있나요?

`var` 키워드는 자바스크립트에서 새로운 변수를 선언하기 위한 키워드입니다. `var`로 선언된 변수는 선언만 하고 초기화하지 않아도 기본적으로 `undefined`로 초기화됩니다.

<br/>

**var 키워드의 문제점**

1. **변수 중복 선언 가능**: 같은 스코프 내에서 동일한 이름의 변수를 중복 선언할 수 있으며, 이는 의도하지 않은 값의 재할당을 초래할 수 있습니다.
2. **함수 레벨 스코프**: `var` 키워드는 블록 레벨 스코프가 아닌 함수 레벨 스코프를 가집니다. 이는 블록 내에서 선언된 변수가 해당 블록 외부에서도 접근 가능하게 만듭니다.
3. **변수 호이스팅**: `var`로 선언된 변수는 호이스팅으로 인해 선언된 위치보다 상위에서 접근할 수 있으며, 초기화되지 않은 변수에 접근하면 `undefined`를 반환합니다.

<br/>

### let 키워드는 무엇이고 어떤 특징이 있나요?

**`let`** 키워드는 ES6에서 도입된 변수 선언을 위한 키워드로, **`var`** 키워드의 단점을 보완합니다.

<br/>

 **let 키워드의 특징**

1. **변수 중복 선언 금지**: 같은 스코프 내에서 동일한 이름의 변수를 중복 선언할 수 없으며, 이를 시도하면 문법 에러(SyntaxError)가 발생합니다.
2. **블록 레벨 스코프**: `let` 키워드는 블록 레벨 스코프를 가지며, 블록 내에서 선언된 변수는 해당 블록 외부에서 접근할 수 없습니다.
3. **변수 호이스팅**: `let` 키워드로 선언된 변수도 호이스팅되지만, 초기화되기 전에는 접근할 수 없습니다. 이를 일시적 사각지대(TDZ)라고 합니다.
4. **전역 객체와의 관계**: `let` 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티로 등록되지 않습니다.


<br/>

### var 키워드와 let 키워드의 차이점은 무엇인가요? ✨

`var` 키워드는 함수 레벨 스코프를 가지고, 변수 호이스팅으로 인해 예상치 못한 동작을 할 수 있으며, 중복 선언이 가능합니다. 반면, `let` 키워드는 블록 레벨 스코프를 가지며, 중복 선언이 불가능하고, 변수 호이스팅이 발생하지만 초기화 전에는 접근할 수 없습니다(`TDZ`). `let` 키워드는 이러한 문제들을 해결하여 더 안전하고 예측 가능한 코드를 작성할 수 있게 합니다.

<br/>

### const 키워드란 무엇인가요?
`const` 키워드는 `let` 키워드와 마찬가지로 ES6에서 추가된 문법으로, 상수를 선언하기 위한 키워드입니다.

<br/>

**`const` 키워드의 특징**
- `const` 키워드는 선언과 동시에 초기화 해야 합니다.
- 또한 한번 초기화 된 값에 재할당을 할 수 없습니다.
- 그래서 `const` 키워드에 원시값을 할당 할 경우 상수처럼 사용할 수 있습니다.

<br/>

### └ let과 const의 TDZ(일시적 사각지대)란 무엇인가요?

일시적 사각지대(Temporal Dead Zone, TDZ)는 `let`이나 `const로` 선언된 변수가 선언되기 전에 해당 변수에 접근할 수 없는 구간을 의미합니다. TDZ는 스코프의 시작 지점부터 변수가 선언된 위치까지 지속됩니다. 이 구간에서 변수를 참조하려고 하면 ReferenceError가 발생합니다. 이는 변수가 선언되기 전에 사용되지 않도록 하여 코드의 안전성을 높입니다.

<br/>

### └ const로 선언된 객체나 배열의 내부 속성은 변경할 수 있는 이유는 무엇인가요?
`const`로 선언된 변수는 재할당이 불가능하지만, 객체나 배열 같은 참조형 데이터의 경우 변수에 저장된 참조 주소는 변하지 않기 때문에 내부 속성이나 요소는 변경할 수 있습니다. 즉, `const`는 변수에 할당된 참조의 불변성을 보장하지만, 참조된 객체의 불변성을 보장하지는 않습니다.


<br/>



[⏫](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#javascript-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC)

<br/>


## 스코프
### 스코프란 무엇인가요? ✨
스코프는 식별자가 유효한 범위를 의미합니다. 즉, 변수를 참조(=접근)할 수 있는 유효한 범위나 영역을 지정하는 것을 말합니다. 변수의 선언 위치에 따라 유효 범위가 결정되며, 일반적으로 코드 블록 `{ }` 안에서만 유효합니다. 블록 밖에서는 변수를 참조할 수 없습니다. 스코프의 주요 장점은 이름 충돌을 방지하고, 메모리를 절약할 수 있다는 점입니다.


<br/>

### 스코프의 종류에는 무엇이 있나요?

스코프는 크게 전역 스코프와 지역 스코프로 나뉩니다.

1. **전역 스코프**: 코드의 가장 바깥 영역의 스코프입니다. 전역 스코프에 선언된 변수는 코드 어디에서든 참조할 수 있습니다.
2. **지역 스코프**: 특정 지역 내부에서만 사용되는 스코프입니다. 주로 함수 내부에 선언된 변수를 말하며, 해당 함수와 그 하위 함수에서만 참조할 수 있습니다.

<br/>

### 렉시컬 스코프란 무엇인가요?
스코프를 결정하는 방식에는 크게 정적 스코프와 동적 스코프가 있습니다. 정적 스코프는 함수가 선언되는 위치에 따라 스코프가 결정되는 방식이고, 동적 스코프는 함수가 호출되는 시점에서 스코프가 결정되는 방식입니다. 자바스크립트는 정적 스코프를 따르며, 이를 렉시컬 스코프라고 합니다. 따라서 함수가 어디서 호출되었는지가 아니라, 어디서 선언되었는지가 중요합니다.

<br/>

### 지역 변수와 전역 변수의 차이점은 무엇인가요?

자바스크립트에서 **지역 변수**는 함수 내부에서 선언되며, 그 함수 내부에서만 접근할 수 있습니다. 함수가 실행될 때 생성되고, 함수 실행이 종료되면 소멸합니다. 이는 함수의 실행 컨텍스트에 속하며, 함수 외부에서는 접근할 수 없어 함수의 독립성과 재사용성을 보장합니다.

반면에, **전역 변수**는 함수 외부에서 선언되며, 어떤 함수 내에서도 접근할 수 있는 변수입니다. 전역 변수는 스크립트 어디서나 접근 가능하기 때문에, 여러 함수에서 공유되는 데이터를 처리할 때 유용합니다. 그러나 전역 변수의 과도한 사용은 프로그램의 예측 가능성을 떨어뜨리고, 다른 스크립트와의 변수 이름 충돌 가능성을 높이기 때문에 주의해야 합니다.

<br/>

### 전역 변수로 선언했을 때 발생할 수 있는 문제점은 무엇인가요?

전역 변수를 사용하면 의도하지 않은 문제점이 발생할 가능성이 큽니다. 주요 문제점은 다음과 같습니다

1. **암묵적 결합**: 전역 변수는 코드 어디서든 참조하고 할당할 수 있기 때문에, 코드 간의 의존성이 높아져 예측하기 어려운 동작이 발생할 수 있습니다.
2. **긴 생명 주기**: 전역 변수는 생명 주기가 길기 때문에, 오랜 시간 동안 메모리에 상주하며 변경될 수 있습니다.
3. **검색 속도 저하**: 전역 변수를 참조하기 위해서는 스코프 체인의 끝에 도달해야 하므로, 검색 속도가 다소 느릴 수 있습니다.
4. **이름 충돌**: 자바스크립트는 하나의 전역 스코프를 공유하기 때문에, 다른 파일에서 동일한 이름의 전역 변수를 사용할 경우 예상치 못한 결과가 발생할 수 있습니다.

<br/>


## 실행 컨텍스트
### 실행 컨텍스트란 무엇인가요? ✨✨
실행 컨텍스트는 코드가 평가되고 실행되는 환경을 의미합니다. 이는 소스코드를 실행하는 데 필요한 환경을 제공하고, 코드의 실행 결과를 실제로 관리하는 영역입니다. 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘을 포함합니다. 모든 코드는 실행 컨텍스트를 통해 실행되고 관리됩니다.

<br/>

### 실행 컨텍스트는 어떻게 구성되어 있나요?
실행 컨텍스트는 크게 두 가지 주요 구성 요소로 이루어져 있습니다: 실행 컨텍스트 스택과 렉시컬 환경입니다.

1. **실행 컨텍스트 스택**:
    - 이는 코드의 실행 순서를 관리하는 자료구조로, LIFO(Last In First Out) 구조로 동작합니다. 코드가 실행될 때마다 새로운 실행 컨텍스트가 스택에 쌓이고, 실행이 끝나면 스택에서 제거됩니다.
2. **렉시컬 환경**:
    - 이는 모든 식별자와 바인딩된 값, 스코프를 기록 및 관리하는 자료구조입니다. 키와 값을 갖는 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 키로 등록하고, 그 식별자에 바인딩된 값을 관리합니다.
    - 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체입니다.

<br/>

### 실행 컨텍스트는 언제 생성되나요?
실행 컨텍스트는 주로 세 가지 경우에 생성됩니다:

1. 프로그램이 실행될 때
2. 함수가 호출될 때
3. eval 함수가 호출될 때

<br/>

### 실행 컨텍스트의 특징은 무엇인가요?
1. **실행 순서 관리**:
    - 실행 컨텍스트가 생성되면 자바스크립트 엔진의 콜 스택에 쌓이게 됩니다. 가장 위에 쌓인 실행 컨텍스트부터 처리하면서 코드를 실행하고, 처리가 끝나면 스택에서 제거합니다.
2. **구성 요소**:
    - 실행 컨텍스트는 ES6 기준으로 렉시컬 환경(Lexical Environment)과 변수 환경(Variable Environment)으로 구성됩니다.

<br/>

### 실행 컨텍스트의 렉시컬 환경과 변수 환경은 무엇인가요? (둘이 나누어진 이유는 무엇인가요?)

실행 컨텍스트는 렉시컬 환경과 변수 환경으로 구성됩니다. 각각의 구성 요소는 다음과 같은 역할을 합니다:

### **렉시컬 환경**

렉시컬 환경은 두 가지 주요 구성 요소로 이루어져 있습니다:

1. **외부 참조 환경**: 자바스크립트의 스코프 체인과 관련이 있으며, 상위 실행 컨텍스트의 렉시컬 환경과 연결되어 있습니다.
2. **환경 레코드**: 값들을 저장하고 식별자를 바인딩하는 역할을 합니다. 환경 레코드는 두 가지 유형으로 나눌 수 있습니다:
    - **선언적 환경 레코드**: 변수와 함수 선언 등의 식별자를 바인딩하는 데 사용됩니다.
    - **객체 환경 레코드**: `with` 문과 같은 특수한 상황에서 사용됩니다.

### **변수 환경**

변수 환경은 렉시컬 환경과 유사하게 외부 참조 환경과 환경 레코드로 구성되어 있습니다. 기존의 함수 레벨 스코프를 가지는 `var` 변수를 관리합니다.

<br/>


📍 **실행 컨텍스트에서 렉시컬 환경과 변수 환경이 나눠진 이유**

ES6 이후, 실행 컨텍스트는 함수 선언, 블록문, `try/catch` 문과 같은 곳에서 새로운 렉시컬 환경이 생성됩니다. `let`과 `const` 변수를 사용하면 블록 레벨 스코프가 적용되며, 이를 관리하기 위해 렉시컬 환경과 변수 환경이 분리되었습니다. 기존의 `var` 변수는 함수 레벨 스코프를 가지며 변수 환경에 저장되고, 새로운 블록 레벨 스코프를 가지는 `let`과 `const` 변수는 렉시컬 환경에 저장됩니다.

<br/>

### 실행 컨텍스트의 동작 방식에 대해 설명해주세요.
실행 컨텍스트의 작동 방식은 크게 생성 단계와 실행 단계로 나눌 수 있습니다.

**생성 단계**

1. **`this` 바인딩**: `this`가 바인딩됩니다.
2. **외부 환경 참조 결정**: 스코프 체인을 위한 외부 환경 참조가 결정됩니다.
3. **환경 레코드에 식별자 수집**: 렉시컬 환경과 변수 환경의 환경 레코드에 식별자 정보가 수집됩니다. 이 과정에서 변수와 함수 선언이 실행 컨텍스트에 등록됩니다.

이 단계에서 변수와 함수 선언이 미리 수집되기 때문에, 실제 선언문 이전에 변수에 접근하거나 함수를 호출할 수 있는 호이스팅이 발생합니다.

**실행 단계**

이후 실행 단계에서 자바스크립트 엔진은 생성된 실행 컨텍스트를 기반으로 실제 코드를 실행합니다. 이때 수집된 식별자 정보를 사용하여 변수에 접근하고, 함수를 호출합니다.

<br/>


[⏫](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#javascript-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC)


## 클로저
- 클로저란 무엇인가요? ✨✨
- 클로저의 장,단점은 무엇인가요?
- 클로저 사용 경험이 있나요

<br/>


## 호이스팅
- 호이스팅이란 무엇인가요? ✨✨
- 호이스팅의 동작 방식에 대해 설명해주세요.

<br/>


## this
- this란 무엇인가요? ✨
- this의 특징에 대해 설명해주세요.
- ㄴthis는 코드의 문맥에 따라 가리키는 대상이 달라진다고 했는데 예시를 설명해주세요.
- this 바인딩이란 무엇인가요? ✨
- ㄴ동적 바인딩과 정적 바인딩에 대해 설명해주세요.

<br/>


## 이벤트
- 이벤트 핸들러를 등록하는 방식에 대해 설명해주세요.
- 이벤트 전파(propagation)란 무엇인가요?
- 이벤트 전파를 막는 방법을 설명해주세요.
- 이벤트 캡처링과 버블링이란 무엇인가요? ✨
- ㄴ이벤트 캡처링과 버블링을 적용하는 방법은 무엇인가요?
- 이벤트 위임(delegation)이란 무엇인가요? ✨
- 이벤트를 처리할 때 사용하는 `debounce`와 `throttle`에 대해 알고 있나요?
- `e.preventDefault`와 `e.stopPropagation`에 대해 알고 있나요?
- `event.target`과 `event.currentTarget`의 차이점은 무엇인가요?

<br/>


## 비동기 프로그래밍
- 동기와 비동기의 차이점에 대해 설명해주세요. ✨
- 타이머 함수에 대해 알고 있나요?
- 이벤트 루프란 무엇인가요? ✨
- 이벤트 루프와 태스크 큐에 대해 설명해주세요. ✨
- 마이크로 태스크큐에 대해 알고 있나요?

<br/>


## Promise
- 콜백 함수란 무엇인가요?
- Promise 문법에 대해 설명해주세요.
- ㄴPromise와 callback의 차이점은 무엇인가요? ✨
- `async/await` 문법에 대해 설명해주세요. ✨
- `async`함수가 반환하는 것은 무엇인가요?
- ㄴ`async/await`과 `promise`의 차이점은 무엇인가요? ✨

<br/>


[⏫](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#javascript-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC)

## 배열
- Javascript 배열의 특징을 말해주세요.
- 배열 메소드를 소개해주세요.
- `forEach`와 `map`의 차이점을 설명해주세요.

<br/>


## 함수와 메서드
- 함수와 메소드의 차이점은 무엇인가요?
- Javascript의 함수 정의 방법을 모두 설명해주세요. ✨✨
- 함수 선언문과 함수 표현식의 차이를 설명해주세요. ✨
- 즉시 실행 함수(IIFE)에 대해 설명해주세요.
- 고차 함수는 무엇인가요?
- 익명 함수는 주로 어떤 상황에서 사용하나요? ✨

<br/>

## 객체
- Javascript의 객체는 무엇인가요?
- 객체를 생성하는 방법은 무엇이 있나요?
- 전역 객체란 무엇인가요?
- 빌트인 객체와 호스트 객체에 대해 설명해주세요.
- 얕은 복사와 깊은 복사에 대해 설명해주세요.

<br/>


## 생성자 함수에 의한 객체 생성
- 생성자 함수는 무엇인가요? ✨
- 생성자 함수를 통한 인스턴스 생성과정을 설명해주세요. ✨
- 객체 리터럴과 생성자 함수의 차이점은 무엇인가요?

<br/>


## 제너레이터
- 제너레이터란 무엇인가요?
- 제너레이터 함수의 동작 방식은 무엇인가요?

<br/>


## 객체지향 프로그래밍과 프로토타입
- 객체지향 프로그래밍이란 무엇인가요? 
- 객체지향 프로그래밍에서 객체란 무엇인가요?
- 객체지향 프로그래밍의 특징을 설명해주세요.
- Javascript는 객체지향 프로그래밍 언어인가요?
- Javascript에서 객체지향 프로그래밍을 어떻게 구현하나요? ✨
- 프로토타입이란 무엇인가요? ✨


<br/>

## 클래스
- 클래스 문법의 특징은 무엇인가요?
- 클래스에는 어떤 값들이 포함되나요?

<br/>


## 스프레드 문법과 구조 분해 할당
- 스프레드 문법에 대해 설명해주세요.
- 스프레드 문법은 어디에 적용할 수 있나요?
- 스프레드 연산자의 단점에 대해 설명해주세요.
- 구조 분해 할당을 설명해주세요.
- 구조 분해 할당 적용 예시를 소개해주세요.

<br/>

 
## 에러
- Javascript에서 에러를 처리하는 방법에 대해 설명해주세요.

<br/>


## Typescript
- Javascript와 Typescript의 차이는 무엇인가요?
- Typescript의 장점은 무엇인가요?

<br/>


## 브라우저 렌더링 과정
- 브라우저 렌더링 과정에서 "Javascript"는 어떻게 작동하나요? ✨

<br/>

[⏫](https://github.com/eeeyooon/frontend-interview-handbook/blob/main/1.%20Javascript/javascript.md#javascript-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC)

<br/>



<br/>
<br/>
